# KMP算法原理

​		采用朴素模式匹配算法，由于需要需要对主串进行遍历，而通常情况下主串n >> m，时间开销会很大。

​		KMP算法的核心是创建一个next数组，从而保证主串指针不回溯，next数组用于存储当出现不匹配现象时，模式串可以向前移动的位置。



KMP算法最坏时间复杂度 = O(m + n)

求next数组最坏的时间复杂度 = O(n)



# 求模式串的next数组

**next数组的作用：**当模式串的第j个字符失配时，从模式串的第next[j]的位置继续往后匹配。



注意：在手算next数组时，next[1] = 0， next[2] = 1。这两个空是可以直接填上去不需要计算的。



# next数组的优化

​		进行模式串匹配并且在第j个位置出现失配时，说明当前主串的字符不可能等于第j个位置的字符。因此，模式串第j个位置之前与第j个位置相同的字符肯定也不可能与主串这个位置的字符匹配。所以，next数组可以优化为nextval数组避免这种情况。



注：nextval[1] = 0。计算nextval数组时需要先把该模式串的next数组求出来。



### **步骤：**

- nextval[1] = 0；
- 进行数组第二个位置的匹配，找到第二个位置下j = next[2]的位置所对应的字符，若与第二个位置的字符相同，就将nextval[2]的值设置为next[j]对应的值；若不相同，则nextval[2]的值就是next[2]的值。
- 接下来以此类推。