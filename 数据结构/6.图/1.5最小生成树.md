# 最小生成树的概念

1. ### 生成树：

   包含图中**全部顶点**的一个**极小连通子图**。

   

2. ### 最小生成树（最小代价树）：

   找到边的权值之和最小的生成树。

   注意：

   - 最小生成树只研究带权连通无向图，如果图不连通，那么就无法生成树只能是森林；
   - 最小生成树边的数量 = 结点数量 - 1；
   - 去掉最小生成树的任意一条边，都会使其变成不连通的图。



# Prim算法

​		从某一个顶点开始构建生成树，每次都将代价最小的新顶点纳入生成树中，直到所有顶点都纳入为止。



### 算法的执行思想：

1. 设置**isJoin[N]**来记录每个顶点**是否加入最小生成树**，使用**lowCost[N]**来存储当前状态下**已经生成的树到还未加入的顶点中代价的最小值**。

2. 从V0开始，总共需要n-1轮循环处理。

3. 每一轮都循环遍历所有结点，找到lowCost最低且没加入树的顶点；

4. 再次循环遍历，**更新**还没加入的各个顶点的lowCost值。

   

注：同一个图中从任意顶点出发寻找最小生成树，得到的最小生成树的权值之和都是一样的。



# Kruskal算法

​		每次都选择一条权值最小的边，使这条边的两头连通（已经连通了就不选），直到所有结点都连通。



### 算法的执行思想：

1. 将每条边按照权值大小进行排序（从小到大）；

2. 检查最小的边对应的两个顶点是否连通（并查集检查是否处于同一集合），若不连通则连接起来，否则检查下一条边；

3. 检查第二条边；

4. 以此类推。

   

### 比较：

1. **Prim算法：**时间复杂度为O(|V|^2^)，使用于边稠密图；
2. **Kruskal算法：**时间复杂度为O(|E|log~2~|E|)，适用于边稀疏图。